# -*- coding: utf-8 -*-
"""Atividade1-Pantanal-Dev.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m9SBnlwVDjQE9EExhpCw4YKDyD4E2XE4

## Importando dados no Drive
"""

import pandas as pd
from imblearn.datasets import make_imbalance

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv('/content/drive/MyDrive/PantanalDev/creditcard.csv')

df.head(10)

df['Class'].value_counts()

df[['Time', 'Amount']].describe(include='all').round()

"""## Random Undersampling
Estratégia de redução de exemplos da classe majoritária para ter a mesma quantidade de exemplos da classe minoritária.
"""

from imblearn.under_sampling import RandomUnderSampler
import matplotlib.pyplot as plt
from collections import Counter

X = df.drop('Class', axis=1)
y = df['Class']

under_sampler = RandomUnderSampler(sampling_strategy='majority')
X_under, y_under = under_sampler.fit_resample(X, y)

freq_class = sorted(Counter(y).items())
freq_classU = sorted(Counter(y_under).items())
print('Antes =',freq_class)
print('Depois = ', freq_classU)

undersample = RandomUnderSampler(sampling_strategy='not minority')
X_under, y_under = undersample.fit_resample(X, y)

freq_classU = sorted(Counter(y_under).items())
print(freq_class)
print(freq_classU)

"""## Random Oversampling
Estratégia de amostragem em que ao invés de remover (under) é replicado (over) os dados da classe minoritária até ter a mesma quantidade que a classe majoritária (ou uma quantidade definida).

*   sampling_strategy='minority' : Aumenta os dados da classe minoritária.
*   sampling_strategy='not minority': Aumenta os dados de todas as classes exceto a minoritária.
*   sampling_strategy='not majority': Aumenta os dados de todas as classes exceto a majoritária.


"""

from imblearn.over_sampling import RandomOverSampler

over__sampler = RandomOverSampler(sampling_strategy='minority')

X_over, y_over = over__sampler.fit_resample(X, y)
freq_classO = sorted(Counter(y_over).items())
print('Antes = ', freq_class)
print('Depois = ', freq_classO)

over__sampler = RandomOverSampler(sampling_strategy='not minority')

X_over, y_over = over__sampler.fit_resample(X, y)
freq_classO = sorted(Counter(y_over).items())
print('Antes = ', freq_class)
print('Depois = ', freq_classO)

over__sampler = RandomOverSampler(sampling_strategy='not majority')

X_over, y_over = over__sampler.fit_resample(X, y)
freq_classO = sorted(Counter(y_over).items())
print('Antes = ', freq_class)
print('Depois = ', freq_classO)

"""## SMOTE
Synthetic Minority Oversampling Technique é uma estratégia de oversampling baseada em vizinhos mais próximos para selecionar os objetos as serem amostrados.
"""

from imblearn.over_sampling import SMOTE

SM = SMOTE(sampling_strategy='minority')
X_smote, y_smote = SM.fit_resample(X, y)
freq_classS = sorted(Counter(y_smote).items())
print('Antes = ', freq_class)
print('Depois = ', freq_classS)

print(X_smote.shape)

"""## 3-NN
Avaliar o impacto na base de dados do detecção de fraudes em cartões de créditos com o algoritmo de classificação 3-NN.

"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix

X_train, X_test, y_train, y_test = train_test_split(X_smote, y_smote, test_size=0.2)
knn = KNeighborsClassifier(n_neighbors=3)
knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)

print("Relatório de Classificação:")
print(classification_report(y_test, y_pred))

print("Matriz de Confusão:")
print(confusion_matrix(y_test, y_pred))

"""## Matriz de Confusão"""

import seaborn as sns
import matplotlib.pyplot as plt

matrix = confusion_matrix(y_test, y_pred)
sns.heatmap(matrix, annot=True, fmt='d', cmap='Purples')